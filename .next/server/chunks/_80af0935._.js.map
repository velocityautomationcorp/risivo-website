{"version":3,"sources":["../../../node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","../../../lib/accounting/hooks.ts/__nextjs-internal-proxy.mjs","../../../lib/accounting/types.ts","../../../lib/accounting/integration.ts","../../../lib/accounting/quickbooks.ts","../../../lib/accounting/xero.ts","../../../lib/accounting/index.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const useARaging = registerClientReference(\n    function() { throw new Error(\"Attempted to call useARaging() from the server but useARaging is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useARaging\",\n);\nexport const useAccountingCustomers = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingCustomers() from the server but useAccountingCustomers is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingCustomers\",\n);\nexport const useAccountingInit = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingInit() from the server but useAccountingInit is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingInit\",\n);\nexport const useAccountingIntegration = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingIntegration() from the server but useAccountingIntegration is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingIntegration\",\n);\nexport const useAccountingInvoices = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingInvoices() from the server but useAccountingInvoices is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingInvoices\",\n);\nexport const useAccountingPayments = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingPayments() from the server but useAccountingPayments is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingPayments\",\n);\nexport const useAccountingSync = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAccountingSync() from the server but useAccountingSync is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useAccountingSync\",\n);\nexport const useGLAccounts = registerClientReference(\n    function() { throw new Error(\"Attempted to call useGLAccounts() from the server but useGLAccounts is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useGLAccounts\",\n);\nexport const useJournalEntries = registerClientReference(\n    function() { throw new Error(\"Attempted to call useJournalEntries() from the server but useJournalEntries is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useJournalEntries\",\n);\nexport const useSyncQueue = registerClientReference(\n    function() { throw new Error(\"Attempted to call useSyncQueue() from the server but useSyncQueue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useSyncQueue\",\n);\nexport const useTaxCodes = registerClientReference(\n    function() { throw new Error(\"Attempted to call useTaxCodes() from the server but useTaxCodes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useTaxCodes\",\n);\nexport const useTrialBalance = registerClientReference(\n    function() { throw new Error(\"Attempted to call useTrialBalance() from the server but useTrialBalance is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/accounting/hooks.ts\",\n    \"useTrialBalance\",\n);\n","// Accounting Integration Types\n// Shared types between CRM Revenue Engine and Accounting Software\n\n// ==========================================\n// CORE ACCOUNTING TYPES\n// ==========================================\n\n// Chart of Accounts - General Ledger Account Types\nexport type AccountType = \n  | 'asset'           // Bank, Accounts Receivable, Inventory\n  | 'liability'       // Accounts Payable, Loans, Credit Cards\n  | 'equity'          // Owner's Equity, Retained Earnings\n  | 'revenue'         // Sales, Service Revenue, Interest Income\n  | 'expense'         // Cost of Goods Sold, Operating Expenses\n  | 'contra_asset'    // Accumulated Depreciation, Allowance for Doubtful Accounts\n  | 'contra_liability'\n  | 'contra_equity'\n  | 'contra_revenue'\n  | 'contra_expense'\n\nexport interface GLAccount {\n  id: string\n  accountCode: string        // e.g., '1000', '4000', '5000'\n  accountName: string        // e.g., 'Cash', 'Accounts Receivable'\n  accountType: AccountType\n  parentAccountId?: string   // For sub-accounts\n  description?: string\n  isActive: boolean\n  balance: number\n  currency: string\n  createdAt: string\n  updatedAt: string\n}\n\n// Journal Entry for Double-Entry Bookkeeping\nexport interface JournalEntry {\n  id: string\n  entryNumber: string        // e.g., 'JE-2024-001'\n  date: string               // Transaction date\n  description: string        // Entry description\n  reference?: string         // External reference (invoice #, payment #)\n  referenceType?: 'invoice' | 'payment' | 'expense' | 'manual' | 'adjustment'\n  referenceId?: string       // ID of the source document\n  lines: JournalEntryLine[]\n  status: 'draft' | 'posted' | 'voided'\n  totalDebit: number\n  totalCredit: number\n  createdBy?: string\n  createdAt: string\n  postedAt?: string\n  voidedAt?: string\n  voidReason?: string\n}\n\nexport interface JournalEntryLine {\n  id: string\n  accountId: string          // GL Account ID\n  accountCode: string        // Denormalized for display\n  accountName: string        // Denormalized for display\n  description?: string       // Line description\n  debit: number\n  credit: number\n  taxCodeId?: string\n  taxAmount?: number\n}\n\n// Tax Configuration\nexport interface TaxCode {\n  id: string\n  code: string               // e.g., 'VAT20', 'GST', 'TAX-EXEMPT'\n  name: string               // e.g., 'VAT 20%', 'No Tax'\n  rate: number               // Percentage (e.g., 20 for 20%)\n  type: 'sales' | 'purchase' | 'both'\n  accountId?: string         // GL Account for tax collected/paid\n  isDefault: boolean\n  isActive: boolean\n  createdAt: string\n}\n\n// ==========================================\n// SHARED DATA TYPES (CRM â†” Accounting)\n// ==========================================\n\n// Customer - Unified between CRM Contacts and Accounting Customers\nexport interface AccountingCustomer {\n  id: string\n  customerCode: string       // e.g., 'CUST-001'\n  companyName: string\n  contactPerson?: string\n  billingEmail: string\n  phone?: string\n  address?: string\n  city?: string\n  state?: string\n  postalCode?: string\n  country?: string\n  currency: string\n  taxId?: string             // VAT number, EIN, etc.\n  paymentTerms?: number      // Days (e.g., 30)\n  creditLimit?: number\n  status: 'active' | 'inactive' | 'suspended'\n  // CRM linking\n  crmContactId?: string      // Link to CRM contact\n  subAccountId: string       // Which sub-account owns this\n  createdAt: string\n  updatedAt: string\n}\n\n// Invoice - Extended for accounting\nexport interface AccountingInvoice {\n  id: string\n  invoiceNumber: string      // e.g., 'INV-001'\n  customerId: string         // FK to AccountingCustomer\n  customerName: string       // Denormalized\n  customerEmail?: string\n  // Amounts\n  subtotal: number\n  taxAmount: number\n  discountAmount: number\n  total: number\n  amountPaid: number\n  amountDue: number\n  currency: string\n  // Dates\n  issueDate: string\n  dueDate: string\n  paidDate?: string\n  // Status\n  status: 'draft' | 'sent' | 'viewed' | 'partial' | 'paid' | 'overdue' | 'cancelled' | 'void'\n  // Line items\n  items: AccountingInvoiceItem[]\n  // Accounting\n  journalEntryId?: string    // Link to journal entry\n  arAccountId?: string       // Accounts Receivable GL account\n  revenueAccountId?: string  // Revenue GL account\n  // CRM linking\n  crmInvoiceId?: string      // Link to CRM invoice\n  subAccountId: string\n  // Metadata\n  notes?: string\n  terms?: string\n  createdAt: string\n  updatedAt: string\n  syncedAt?: string          // Last sync timestamp\n}\n\nexport interface AccountingInvoiceItem {\n  id: string\n  description: string\n  quantity: number\n  unitPrice: number\n  amount: number             // quantity * unitPrice\n  taxCodeId?: string\n  taxRate?: number\n  taxAmount?: number\n  total: number              // amount + taxAmount\n  accountId?: string         // Revenue GL account for this item\n  productId?: string         // Link to product\n}\n\n// Payment - Extended for accounting\nexport interface AccountingPayment {\n  id: string\n  paymentNumber: string      // e.g., 'PAY-001'\n  customerId: string\n  customerName: string\n  // Invoice linking\n  invoiceId?: string\n  invoiceNumber?: string\n  // Amount\n  amount: number\n  currency: string\n  // Method & Status\n  method: 'credit_card' | 'bank_transfer' | 'check' | 'cash' | 'paypal' | 'stripe' | 'other'\n  status: 'pending' | 'completed' | 'failed' | 'refunded' | 'partial_refund'\n  // Gateway info\n  gatewayId?: string         // Stripe/PayPal transaction ID\n  gateway?: string           // 'stripe', 'paypal', 'manual'\n  // Dates\n  date: string\n  processedAt?: string\n  // Accounting\n  journalEntryId?: string\n  bankAccountId?: string     // GL account for bank/cash\n  // Reference\n  reference?: string\n  notes?: string\n  // CRM linking\n  crmPaymentId?: string\n  subAccountId: string\n  createdAt: string\n  updatedAt: string\n  syncedAt?: string\n}\n\n// ==========================================\n// SYNC & INTEGRATION TYPES\n// ==========================================\n\nexport type IntegrationType = 'internal' | 'quickbooks' | 'xero'\n\nexport interface AccountingIntegration {\n  id: string\n  subAccountId: string\n  type: IntegrationType\n  status: 'active' | 'inactive' | 'error' | 'pending_auth'\n  // OAuth credentials (for QuickBooks/Xero)\n  accessToken?: string\n  refreshToken?: string\n  tokenExpiresAt?: string\n  realmId?: string           // QuickBooks company ID\n  tenantId?: string          // Xero organization ID\n  // Settings\n  settings: {\n    syncCustomers: boolean\n    syncInvoices: boolean\n    syncPayments: boolean\n    syncProducts: boolean\n    defaultArAccountId?: string\n    defaultRevenueAccountId?: string\n    defaultBankAccountId?: string\n    autoPostJournalEntries: boolean\n  }\n  lastSyncAt?: string\n  lastError?: string\n  createdAt: string\n  updatedAt: string\n}\n\n// Sync Queue for retry mechanism\nexport type SyncEntityType = 'customer' | 'invoice' | 'payment' | 'product' | 'journal_entry'\nexport type SyncAction = 'create' | 'update' | 'delete' | 'sync'\n\nexport interface SyncQueueItem {\n  id: string\n  subAccountId: string\n  integrationType: IntegrationType\n  entityType: SyncEntityType\n  entityId: string\n  action: SyncAction\n  payload: any               // The data to sync\n  status: 'pending' | 'processing' | 'completed' | 'failed'\n  attempts: number\n  maxAttempts: number\n  lastError?: string\n  nextRetryAt?: string\n  createdAt: string\n  processedAt?: string\n}\n\n// Sync Result\nexport interface SyncResult {\n  success: boolean\n  entityType: SyncEntityType\n  entityId: string\n  action: SyncAction\n  externalId?: string        // ID in external system\n  error?: string\n  timestamp: string\n}\n\n// ==========================================\n// DEFAULT CHART OF ACCOUNTS\n// ==========================================\n\nexport const DEFAULT_CHART_OF_ACCOUNTS: Omit<GLAccount, 'id' | 'balance' | 'createdAt' | 'updatedAt'>[] = [\n  // Assets (1000-1999)\n  { accountCode: '1000', accountName: 'Cash', accountType: 'asset', isActive: true, currency: 'USD', description: 'Cash on hand' },\n  { accountCode: '1010', accountName: 'Bank Account', accountType: 'asset', isActive: true, currency: 'USD', description: 'Primary bank account' },\n  { accountCode: '1100', accountName: 'Accounts Receivable', accountType: 'asset', isActive: true, currency: 'USD', description: 'Money owed by customers' },\n  { accountCode: '1200', accountName: 'Inventory', accountType: 'asset', isActive: true, currency: 'USD', description: 'Products for sale' },\n  { accountCode: '1300', accountName: 'Prepaid Expenses', accountType: 'asset', isActive: true, currency: 'USD', description: 'Expenses paid in advance' },\n  \n  // Liabilities (2000-2999)\n  { accountCode: '2000', accountName: 'Accounts Payable', accountType: 'liability', isActive: true, currency: 'USD', description: 'Money owed to vendors' },\n  { accountCode: '2100', accountName: 'Credit Card Payable', accountType: 'liability', isActive: true, currency: 'USD', description: 'Credit card balance' },\n  { accountCode: '2200', accountName: 'Sales Tax Payable', accountType: 'liability', isActive: true, currency: 'USD', description: 'Sales tax collected' },\n  { accountCode: '2300', accountName: 'Unearned Revenue', accountType: 'liability', isActive: true, currency: 'USD', description: 'Prepayments from customers' },\n  \n  // Equity (3000-3999)\n  { accountCode: '3000', accountName: 'Owner\\'s Equity', accountType: 'equity', isActive: true, currency: 'USD', description: 'Owner investment' },\n  { accountCode: '3100', accountName: 'Retained Earnings', accountType: 'equity', isActive: true, currency: 'USD', description: 'Accumulated profits' },\n  \n  // Revenue (4000-4999)\n  { accountCode: '4000', accountName: 'Sales Revenue', accountType: 'revenue', isActive: true, currency: 'USD', description: 'Product sales' },\n  { accountCode: '4100', accountName: 'Service Revenue', accountType: 'revenue', isActive: true, currency: 'USD', description: 'Service income' },\n  { accountCode: '4200', accountName: 'Subscription Revenue', accountType: 'revenue', isActive: true, currency: 'USD', description: 'Recurring subscriptions' },\n  { accountCode: '4900', accountName: 'Other Income', accountType: 'revenue', isActive: true, currency: 'USD', description: 'Miscellaneous income' },\n  \n  // Expenses (5000-5999)\n  { accountCode: '5000', accountName: 'Cost of Goods Sold', accountType: 'expense', isActive: true, currency: 'USD', description: 'Direct product costs' },\n  { accountCode: '5100', accountName: 'Salaries & Wages', accountType: 'expense', isActive: true, currency: 'USD', description: 'Employee compensation' },\n  { accountCode: '5200', accountName: 'Rent Expense', accountType: 'expense', isActive: true, currency: 'USD', description: 'Office/warehouse rent' },\n  { accountCode: '5300', accountName: 'Utilities', accountType: 'expense', isActive: true, currency: 'USD', description: 'Electric, water, internet' },\n  { accountCode: '5400', accountName: 'Marketing & Advertising', accountType: 'expense', isActive: true, currency: 'USD', description: 'Marketing costs' },\n  { accountCode: '5500', accountName: 'Software & Subscriptions', accountType: 'expense', isActive: true, currency: 'USD', description: 'SaaS and tools' },\n  { accountCode: '5600', accountName: 'Professional Services', accountType: 'expense', isActive: true, currency: 'USD', description: 'Legal, accounting, consulting' },\n  { accountCode: '5700', accountName: 'Bank Fees', accountType: 'expense', isActive: true, currency: 'USD', description: 'Bank and payment processing fees' },\n  { accountCode: '5800', accountName: 'Depreciation', accountType: 'expense', isActive: true, currency: 'USD', description: 'Asset depreciation' },\n  { accountCode: '5900', accountName: 'Other Expenses', accountType: 'expense', isActive: true, currency: 'USD', description: 'Miscellaneous expenses' },\n]\n\n// Default Tax Codes\nexport const DEFAULT_TAX_CODES: Omit<TaxCode, 'id' | 'createdAt'>[] = [\n  { code: 'NO-TAX', name: 'No Tax', rate: 0, type: 'both', isDefault: false, isActive: true },\n  { code: 'TAX-10', name: 'Sales Tax 10%', rate: 10, type: 'sales', isDefault: true, isActive: true },\n  { code: 'TAX-20', name: 'VAT 20%', rate: 20, type: 'both', isDefault: false, isActive: true },\n  { code: 'TAX-7', name: 'Sales Tax 7%', rate: 7, type: 'sales', isDefault: false, isActive: true },\n]\n\n// Risivo Hub Sub-Account ID\nexport const RISIVO_HUB_SUB_ACCOUNT_ID = 'risivo-hub'\n","// Accounting Integration Layer\n// Handles sync between Revenue Engine and Accounting Software\n// Supports: Internal sync (Risivo Hub) and External (QuickBooks, Xero)\n\nimport type {\n  AccountingCustomer,\n  AccountingInvoice,\n  AccountingInvoiceItem,\n  AccountingPayment,\n  AccountingIntegration,\n  GLAccount,\n  JournalEntry,\n  JournalEntryLine,\n  TaxCode,\n  SyncQueueItem,\n  SyncResult,\n  IntegrationType,\n  SyncEntityType,\n  SyncAction,\n} from './types'\n\nimport {\n  DEFAULT_CHART_OF_ACCOUNTS,\n  DEFAULT_TAX_CODES,\n  RISIVO_HUB_SUB_ACCOUNT_ID,\n} from './types'\n\n// ==========================================\n// INTERNAL SYNC SERVICE (Risivo Hub)\n// ==========================================\n\n// localStorage keys for internal accounting\nconst STORAGE_KEYS = {\n  invoices: 'accounting_invoices',\n  payments: 'accounting_payments',\n  customers: 'accounting_customers',\n  gl_accounts: 'accounting_gl_accounts',\n  journal_entries: 'accounting_journal_entries',\n  tax_codes: 'accounting_tax_codes',\n  sync_queue: 'accounting_sync_queue',\n  integrations: 'accounting_integrations',\n}\n\n// Helper to safely access localStorage (SSR compatible)\nfunction getStorage(key: string): any[] {\n  if (typeof window === 'undefined') return []\n  try {\n    const data = localStorage.getItem(key)\n    return data ? JSON.parse(data) : []\n  } catch {\n    return []\n  }\n}\n\nfunction setStorage(key: string, data: any[]): void {\n  if (typeof window === 'undefined') return\n  try {\n    localStorage.setItem(key, JSON.stringify(data))\n  } catch (e) {\n    console.error('localStorage error:', e)\n  }\n}\n\n// Generate unique IDs\nfunction generateId(prefix: string): string {\n  const timestamp = Date.now().toString(36)\n  const random = Math.random().toString(36).substring(2, 8)\n  return `${prefix}_${timestamp}${random}`\n}\n\n// ==========================================\n// INTERNAL ACCOUNTING SERVICE\n// ==========================================\n\nexport const internalAccountingService = {\n  // -----------------------------------------\n  // GL ACCOUNTS (Chart of Accounts)\n  // -----------------------------------------\n  \n  initializeChartOfAccounts: (subAccountId: string): GLAccount[] => {\n    const existing = getStorage(STORAGE_KEYS.gl_accounts)\n    const subAccountAccounts = existing.filter((a: GLAccount) => \n      a.id.startsWith(subAccountId)\n    )\n    \n    if (subAccountAccounts.length > 0) {\n      return subAccountAccounts\n    }\n    \n    // Initialize with default chart of accounts\n    const now = new Date().toISOString()\n    const newAccounts: GLAccount[] = DEFAULT_CHART_OF_ACCOUNTS.map(account => ({\n      ...account,\n      id: `${subAccountId}_${generateId('gl')}`,\n      balance: 0,\n      createdAt: now,\n      updatedAt: now,\n    }))\n    \n    setStorage(STORAGE_KEYS.gl_accounts, [...existing, ...newAccounts])\n    return newAccounts\n  },\n  \n  getGLAccounts: (subAccountId: string): GLAccount[] => {\n    const accounts = getStorage(STORAGE_KEYS.gl_accounts)\n    return accounts.filter((a: GLAccount) => a.id.startsWith(subAccountId) || !a.id.includes('_'))\n  },\n  \n  getGLAccountByCode: (subAccountId: string, code: string): GLAccount | undefined => {\n    const accounts = internalAccountingService.getGLAccounts(subAccountId)\n    return accounts.find(a => a.accountCode === code)\n  },\n  \n  createGLAccount: (subAccountId: string, account: Omit<GLAccount, 'id' | 'balance' | 'createdAt' | 'updatedAt'>): GLAccount => {\n    const accounts = getStorage(STORAGE_KEYS.gl_accounts)\n    const now = new Date().toISOString()\n    \n    const newAccount: GLAccount = {\n      ...account,\n      id: `${subAccountId}_${generateId('gl')}`,\n      balance: 0,\n      createdAt: now,\n      updatedAt: now,\n    }\n    \n    setStorage(STORAGE_KEYS.gl_accounts, [...accounts, newAccount])\n    return newAccount\n  },\n  \n  updateGLAccountBalance: (accountId: string, amount: number, isDebit: boolean): void => {\n    const accounts = getStorage(STORAGE_KEYS.gl_accounts)\n    const index = accounts.findIndex((a: GLAccount) => a.id === accountId)\n    \n    if (index === -1) return\n    \n    const account = accounts[index]\n    // Debits increase asset/expense, decrease liability/equity/revenue\n    // Credits decrease asset/expense, increase liability/equity/revenue\n    const isNormalDebitAccount = ['asset', 'expense', 'contra_liability', 'contra_equity', 'contra_revenue'].includes(account.accountType)\n    \n    if (isDebit) {\n      account.balance += isNormalDebitAccount ? amount : -amount\n    } else {\n      account.balance += isNormalDebitAccount ? -amount : amount\n    }\n    \n    account.updatedAt = new Date().toISOString()\n    accounts[index] = account\n    setStorage(STORAGE_KEYS.gl_accounts, accounts)\n  },\n  \n  // -----------------------------------------\n  // TAX CODES\n  // -----------------------------------------\n  \n  initializeTaxCodes: (subAccountId: string): TaxCode[] => {\n    const existing = getStorage(STORAGE_KEYS.tax_codes)\n    const subAccountCodes = existing.filter((t: TaxCode) => \n      t.id.startsWith(subAccountId)\n    )\n    \n    if (subAccountCodes.length > 0) {\n      return subAccountCodes\n    }\n    \n    const now = new Date().toISOString()\n    const newCodes: TaxCode[] = DEFAULT_TAX_CODES.map(code => ({\n      ...code,\n      id: `${subAccountId}_${generateId('tax')}`,\n      createdAt: now,\n    }))\n    \n    setStorage(STORAGE_KEYS.tax_codes, [...existing, ...newCodes])\n    return newCodes\n  },\n  \n  getTaxCodes: (subAccountId: string): TaxCode[] => {\n    const codes = getStorage(STORAGE_KEYS.tax_codes)\n    return codes.filter((t: TaxCode) => t.id.startsWith(subAccountId) || !t.id.includes('_'))\n  },\n  \n  // -----------------------------------------\n  // JOURNAL ENTRIES\n  // -----------------------------------------\n  \n  getJournalEntries: (subAccountId: string, filters?: {\n    status?: string\n    referenceType?: string\n    startDate?: string\n    endDate?: string\n  }): JournalEntry[] => {\n    let entries = getStorage(STORAGE_KEYS.journal_entries)\n    entries = entries.filter((e: JournalEntry) => e.id.startsWith(subAccountId))\n    \n    if (filters?.status) {\n      entries = entries.filter((e: JournalEntry) => e.status === filters.status)\n    }\n    if (filters?.referenceType) {\n      entries = entries.filter((e: JournalEntry) => e.referenceType === filters.referenceType)\n    }\n    if (filters?.startDate) {\n      entries = entries.filter((e: JournalEntry) => e.date >= filters.startDate!)\n    }\n    if (filters?.endDate) {\n      entries = entries.filter((e: JournalEntry) => e.date <= filters.endDate!)\n    }\n    \n    return entries.sort((a: JournalEntry, b: JournalEntry) => \n      new Date(b.date).getTime() - new Date(a.date).getTime()\n    )\n  },\n  \n  createJournalEntry: (\n    subAccountId: string, \n    entry: Omit<JournalEntry, 'id' | 'entryNumber' | 'createdAt'>\n  ): JournalEntry => {\n    const entries = getStorage(STORAGE_KEYS.journal_entries)\n    const subAccountEntries = entries.filter((e: JournalEntry) => e.id.startsWith(subAccountId))\n    \n    const now = new Date().toISOString()\n    const year = new Date().getFullYear()\n    const entryNumber = `JE-${year}-${String(subAccountEntries.length + 1).padStart(4, '0')}`\n    \n    const newEntry: JournalEntry = {\n      ...entry,\n      id: `${subAccountId}_${generateId('je')}`,\n      entryNumber,\n      createdAt: now,\n    }\n    \n    // Validate debits = credits\n    if (newEntry.totalDebit !== newEntry.totalCredit) {\n      throw new Error('Journal entry must balance: total debits must equal total credits')\n    }\n    \n    setStorage(STORAGE_KEYS.journal_entries, [...entries, newEntry])\n    \n    // If posting immediately, update GL account balances\n    if (newEntry.status === 'posted') {\n      for (const line of newEntry.lines) {\n        if (line.debit > 0) {\n          internalAccountingService.updateGLAccountBalance(line.accountId, line.debit, true)\n        }\n        if (line.credit > 0) {\n          internalAccountingService.updateGLAccountBalance(line.accountId, line.credit, false)\n        }\n      }\n    }\n    \n    return newEntry\n  },\n  \n  postJournalEntry: (entryId: string): JournalEntry => {\n    const entries = getStorage(STORAGE_KEYS.journal_entries)\n    const index = entries.findIndex((e: JournalEntry) => e.id === entryId)\n    \n    if (index === -1) {\n      throw new Error('Journal entry not found')\n    }\n    \n    const entry = entries[index]\n    if (entry.status === 'posted') {\n      throw new Error('Journal entry already posted')\n    }\n    if (entry.status === 'voided') {\n      throw new Error('Cannot post voided journal entry')\n    }\n    \n    entry.status = 'posted'\n    entry.postedAt = new Date().toISOString()\n    entries[index] = entry\n    setStorage(STORAGE_KEYS.journal_entries, entries)\n    \n    // Update GL account balances\n    for (const line of entry.lines) {\n      if (line.debit > 0) {\n        internalAccountingService.updateGLAccountBalance(line.accountId, line.debit, true)\n      }\n      if (line.credit > 0) {\n        internalAccountingService.updateGLAccountBalance(line.accountId, line.credit, false)\n      }\n    }\n    \n    return entry\n  },\n  \n  voidJournalEntry: (entryId: string, reason: string): JournalEntry => {\n    const entries = getStorage(STORAGE_KEYS.journal_entries)\n    const index = entries.findIndex((e: JournalEntry) => e.id === entryId)\n    \n    if (index === -1) {\n      throw new Error('Journal entry not found')\n    }\n    \n    const entry = entries[index]\n    if (entry.status === 'voided') {\n      throw new Error('Journal entry already voided')\n    }\n    \n    // If was posted, reverse the GL account impacts\n    if (entry.status === 'posted') {\n      for (const line of entry.lines) {\n        if (line.debit > 0) {\n          // Reverse: credit where we debited\n          internalAccountingService.updateGLAccountBalance(line.accountId, line.debit, false)\n        }\n        if (line.credit > 0) {\n          // Reverse: debit where we credited\n          internalAccountingService.updateGLAccountBalance(line.accountId, line.credit, true)\n        }\n      }\n    }\n    \n    entry.status = 'voided'\n    entry.voidedAt = new Date().toISOString()\n    entry.voidReason = reason\n    entries[index] = entry\n    setStorage(STORAGE_KEYS.journal_entries, entries)\n    \n    return entry\n  },\n  \n  // -----------------------------------------\n  // CUSTOMERS\n  // -----------------------------------------\n  \n  syncCustomer: (subAccountId: string, crmContact: {\n    id: string\n    name: string\n    email: string\n    company?: string\n    phone?: string\n    address?: string\n  }): AccountingCustomer => {\n    const customers = getStorage(STORAGE_KEYS.customers)\n    const existing = customers.find((c: AccountingCustomer) => \n      c.crmContactId === crmContact.id && c.subAccountId === subAccountId\n    )\n    \n    const now = new Date().toISOString()\n    \n    if (existing) {\n      // Update existing customer\n      existing.companyName = crmContact.company || crmContact.name\n      existing.billingEmail = crmContact.email\n      existing.contactPerson = crmContact.name\n      existing.phone = crmContact.phone\n      existing.address = crmContact.address\n      existing.updatedAt = now\n      \n      const index = customers.findIndex((c: AccountingCustomer) => c.id === existing.id)\n      customers[index] = existing\n      setStorage(STORAGE_KEYS.customers, customers)\n      return existing\n    }\n    \n    // Create new customer\n    const customerCount = customers.filter((c: AccountingCustomer) => \n      c.subAccountId === subAccountId\n    ).length\n    \n    const newCustomer: AccountingCustomer = {\n      id: `${subAccountId}_${generateId('cust')}`,\n      customerCode: `CUST-${String(customerCount + 1).padStart(3, '0')}`,\n      companyName: crmContact.company || crmContact.name,\n      contactPerson: crmContact.name,\n      billingEmail: crmContact.email,\n      phone: crmContact.phone,\n      address: crmContact.address,\n      currency: 'USD',\n      status: 'active',\n      crmContactId: crmContact.id,\n      subAccountId,\n      createdAt: now,\n      updatedAt: now,\n    }\n    \n    setStorage(STORAGE_KEYS.customers, [...customers, newCustomer])\n    return newCustomer\n  },\n  \n  getCustomers: (subAccountId: string): AccountingCustomer[] => {\n    const customers = getStorage(STORAGE_KEYS.customers)\n    return customers.filter((c: AccountingCustomer) => c.subAccountId === subAccountId)\n  },\n  \n  getCustomerByCompanyName: (subAccountId: string, companyName: string): AccountingCustomer | undefined => {\n    const customers = internalAccountingService.getCustomers(subAccountId)\n    return customers.find(c => c.companyName.toLowerCase() === companyName.toLowerCase())\n  },\n  \n  // -----------------------------------------\n  // INVOICES\n  // -----------------------------------------\n  \n  syncInvoice: (subAccountId: string, crmInvoice: {\n    id: string\n    invoiceNumber?: string\n    contactId?: string\n    contactName?: string\n    contactEmail?: string\n    items: Array<{\n      description: string\n      quantity: number\n      unitPrice: number\n      taxRate?: number\n    }>\n    subtotal: number\n    taxAmount: number\n    discountAmount?: number\n    total: number\n    status: string\n    issueDate: string\n    dueDate: string\n    notes?: string\n  }, autoPostJournalEntry = true): { invoice: AccountingInvoice; journalEntry?: JournalEntry } => {\n    const invoices = getStorage(STORAGE_KEYS.invoices)\n    const now = new Date().toISOString()\n    \n    // Find or create customer\n    let customer: AccountingCustomer | undefined\n    if (crmInvoice.contactId) {\n      customer = internalAccountingService.syncCustomer(subAccountId, {\n        id: crmInvoice.contactId,\n        name: crmInvoice.contactName || 'Unknown',\n        email: crmInvoice.contactEmail || '',\n      })\n    }\n    \n    // Check for existing invoice\n    const existingIndex = invoices.findIndex((i: AccountingInvoice) => \n      i.crmInvoiceId === crmInvoice.id && i.subAccountId === subAccountId\n    )\n    \n    // Get default GL accounts\n    const arAccount = internalAccountingService.getGLAccountByCode(subAccountId, '1100') // Accounts Receivable\n    const revenueAccount = internalAccountingService.getGLAccountByCode(subAccountId, '4000') // Sales Revenue\n    const taxAccount = internalAccountingService.getGLAccountByCode(subAccountId, '2200') // Sales Tax Payable\n    \n    // Map invoice items\n    const invoiceItems: AccountingInvoiceItem[] = crmInvoice.items.map((item, idx) => ({\n      id: `${subAccountId}_item_${idx}_${Date.now()}`,\n      description: item.description,\n      quantity: item.quantity,\n      unitPrice: item.unitPrice,\n      amount: item.quantity * item.unitPrice,\n      taxRate: item.taxRate,\n      taxAmount: item.taxRate ? (item.quantity * item.unitPrice * item.taxRate / 100) : 0,\n      total: item.quantity * item.unitPrice + (item.taxRate ? (item.quantity * item.unitPrice * item.taxRate / 100) : 0),\n      accountId: revenueAccount?.id,\n    }))\n    \n    // Map status\n    const statusMap: Record<string, AccountingInvoice['status']> = {\n      draft: 'draft',\n      sent: 'sent',\n      paid: 'paid',\n      overdue: 'overdue',\n      partial: 'partial',\n      cancelled: 'cancelled',\n      void: 'void',\n    }\n    \n    const invoiceCount = invoices.filter((i: AccountingInvoice) => \n      i.subAccountId === subAccountId\n    ).length\n    \n    const invoice: AccountingInvoice = {\n      id: existingIndex >= 0 ? invoices[existingIndex].id : `${subAccountId}_${generateId('inv')}`,\n      invoiceNumber: crmInvoice.invoiceNumber || `INV-${String(invoiceCount + 1).padStart(3, '0')}`,\n      customerId: customer?.id || '',\n      customerName: customer?.companyName || crmInvoice.contactName || 'Unknown',\n      customerEmail: customer?.billingEmail || crmInvoice.contactEmail,\n      subtotal: crmInvoice.subtotal,\n      taxAmount: crmInvoice.taxAmount,\n      discountAmount: crmInvoice.discountAmount || 0,\n      total: crmInvoice.total,\n      amountPaid: crmInvoice.status === 'paid' ? crmInvoice.total : 0,\n      amountDue: crmInvoice.status === 'paid' ? 0 : crmInvoice.total,\n      currency: 'USD',\n      issueDate: crmInvoice.issueDate,\n      dueDate: crmInvoice.dueDate,\n      paidDate: crmInvoice.status === 'paid' ? now : undefined,\n      status: statusMap[crmInvoice.status] || 'draft',\n      items: invoiceItems,\n      arAccountId: arAccount?.id,\n      revenueAccountId: revenueAccount?.id,\n      crmInvoiceId: crmInvoice.id,\n      subAccountId,\n      notes: crmInvoice.notes,\n      createdAt: existingIndex >= 0 ? invoices[existingIndex].createdAt : now,\n      updatedAt: now,\n      syncedAt: now,\n    }\n    \n    if (existingIndex >= 0) {\n      invoices[existingIndex] = invoice\n    } else {\n      invoices.push(invoice)\n    }\n    setStorage(STORAGE_KEYS.invoices, invoices)\n    \n    // Create journal entry for non-draft invoices\n    let journalEntry: JournalEntry | undefined\n    \n    if (invoice.status !== 'draft' && !invoice.journalEntryId && autoPostJournalEntry) {\n      // Double-entry: Debit AR, Credit Revenue, Credit Tax Payable\n      const lines: JournalEntryLine[] = []\n      \n      // Debit: Accounts Receivable\n      if (arAccount) {\n        lines.push({\n          id: generateId('jel'),\n          accountId: arAccount.id,\n          accountCode: arAccount.accountCode,\n          accountName: arAccount.accountName,\n          description: `Invoice ${invoice.invoiceNumber}`,\n          debit: invoice.total,\n          credit: 0,\n        })\n      }\n      \n      // Credit: Revenue\n      if (revenueAccount) {\n        lines.push({\n          id: generateId('jel'),\n          accountId: revenueAccount.id,\n          accountCode: revenueAccount.accountCode,\n          accountName: revenueAccount.accountName,\n          description: `Revenue from ${invoice.invoiceNumber}`,\n          debit: 0,\n          credit: invoice.subtotal - (invoice.discountAmount || 0),\n        })\n      }\n      \n      // Credit: Tax Payable (if any)\n      if (taxAccount && invoice.taxAmount > 0) {\n        lines.push({\n          id: generateId('jel'),\n          accountId: taxAccount.id,\n          accountCode: taxAccount.accountCode,\n          accountName: taxAccount.accountName,\n          description: `Tax on ${invoice.invoiceNumber}`,\n          debit: 0,\n          credit: invoice.taxAmount,\n        })\n      }\n      \n      const totalDebit = lines.reduce((sum, l) => sum + l.debit, 0)\n      const totalCredit = lines.reduce((sum, l) => sum + l.credit, 0)\n      \n      if (lines.length > 0 && totalDebit === totalCredit) {\n        try {\n          journalEntry = internalAccountingService.createJournalEntry(subAccountId, {\n            date: invoice.issueDate,\n            description: `Invoice ${invoice.invoiceNumber} - ${invoice.customerName}`,\n            reference: invoice.invoiceNumber,\n            referenceType: 'invoice',\n            referenceId: invoice.id,\n            lines,\n            status: autoPostJournalEntry ? 'posted' : 'draft',\n            totalDebit,\n            totalCredit,\n          })\n          \n          // Update invoice with journal entry ID\n          invoice.journalEntryId = journalEntry.id\n          const idx = invoices.findIndex((i: AccountingInvoice) => i.id === invoice.id)\n          if (idx >= 0) {\n            invoices[idx] = invoice\n            setStorage(STORAGE_KEYS.invoices, invoices)\n          }\n        } catch (e) {\n          console.error('Failed to create journal entry:', e)\n        }\n      }\n    }\n    \n    return { invoice, journalEntry }\n  },\n  \n  getInvoices: (subAccountId: string, filters?: {\n    status?: string\n    customerId?: string\n    startDate?: string\n    endDate?: string\n  }): AccountingInvoice[] => {\n    let invoices = getStorage(STORAGE_KEYS.invoices)\n    invoices = invoices.filter((i: AccountingInvoice) => i.subAccountId === subAccountId)\n    \n    if (filters?.status) {\n      invoices = invoices.filter((i: AccountingInvoice) => i.status === filters.status)\n    }\n    if (filters?.customerId) {\n      invoices = invoices.filter((i: AccountingInvoice) => i.customerId === filters.customerId)\n    }\n    if (filters?.startDate) {\n      invoices = invoices.filter((i: AccountingInvoice) => i.issueDate >= filters.startDate!)\n    }\n    if (filters?.endDate) {\n      invoices = invoices.filter((i: AccountingInvoice) => i.issueDate <= filters.endDate!)\n    }\n    \n    return invoices.sort((a: AccountingInvoice, b: AccountingInvoice) => \n      new Date(b.issueDate).getTime() - new Date(a.issueDate).getTime()\n    )\n  },\n  \n  // -----------------------------------------\n  // PAYMENTS\n  // -----------------------------------------\n  \n  syncPayment: (subAccountId: string, crmPayment: {\n    id: string\n    paymentNumber?: string\n    invoiceId?: string\n    invoiceNumber?: string\n    contactId?: string\n    contactName?: string\n    amount: number\n    method: string\n    status: string\n    date: string\n    reference?: string\n    notes?: string\n    gatewayId?: string\n    gateway?: string\n  }, autoPostJournalEntry = true): { payment: AccountingPayment; journalEntry?: JournalEntry } => {\n    const payments = getStorage(STORAGE_KEYS.payments)\n    const now = new Date().toISOString()\n    \n    // Find or create customer\n    let customer: AccountingCustomer | undefined\n    if (crmPayment.contactId) {\n      customer = internalAccountingService.syncCustomer(subAccountId, {\n        id: crmPayment.contactId,\n        name: crmPayment.contactName || 'Unknown',\n        email: '',\n      })\n    }\n    \n    // Check for existing payment\n    const existingIndex = payments.findIndex((p: AccountingPayment) => \n      p.crmPaymentId === crmPayment.id && p.subAccountId === subAccountId\n    )\n    \n    // Get default GL accounts\n    const arAccount = internalAccountingService.getGLAccountByCode(subAccountId, '1100') // Accounts Receivable\n    const bankAccount = internalAccountingService.getGLAccountByCode(subAccountId, '1010') // Bank Account\n    \n    // Map payment method\n    const methodMap: Record<string, AccountingPayment['method']> = {\n      credit_card: 'credit_card',\n      bank_transfer: 'bank_transfer',\n      check: 'check',\n      cash: 'cash',\n      paypal: 'paypal',\n      stripe: 'stripe',\n    }\n    \n    // Map status\n    const statusMap: Record<string, AccountingPayment['status']> = {\n      pending: 'pending',\n      completed: 'completed',\n      failed: 'failed',\n      refunded: 'refunded',\n    }\n    \n    const paymentCount = payments.filter((p: AccountingPayment) => \n      p.subAccountId === subAccountId\n    ).length\n    \n    const payment: AccountingPayment = {\n      id: existingIndex >= 0 ? payments[existingIndex].id : `${subAccountId}_${generateId('pay')}`,\n      paymentNumber: crmPayment.paymentNumber || `PAY-${String(paymentCount + 1).padStart(3, '0')}`,\n      customerId: customer?.id || '',\n      customerName: customer?.companyName || crmPayment.contactName || 'Unknown',\n      invoiceId: crmPayment.invoiceId,\n      invoiceNumber: crmPayment.invoiceNumber,\n      amount: crmPayment.amount,\n      currency: 'USD',\n      method: methodMap[crmPayment.method] || 'other',\n      status: statusMap[crmPayment.status] || 'pending',\n      gatewayId: crmPayment.gatewayId,\n      gateway: crmPayment.gateway,\n      date: crmPayment.date,\n      processedAt: crmPayment.status === 'completed' ? now : undefined,\n      bankAccountId: bankAccount?.id,\n      reference: crmPayment.reference,\n      notes: crmPayment.notes,\n      crmPaymentId: crmPayment.id,\n      subAccountId,\n      createdAt: existingIndex >= 0 ? payments[existingIndex].createdAt : now,\n      updatedAt: now,\n      syncedAt: now,\n    }\n    \n    if (existingIndex >= 0) {\n      payments[existingIndex] = payment\n    } else {\n      payments.push(payment)\n    }\n    setStorage(STORAGE_KEYS.payments, payments)\n    \n    // Create journal entry for completed payments\n    let journalEntry: JournalEntry | undefined\n    \n    if (payment.status === 'completed' && !payment.journalEntryId && autoPostJournalEntry) {\n      // Double-entry: Debit Bank, Credit AR\n      const lines: JournalEntryLine[] = []\n      \n      // Debit: Bank/Cash\n      if (bankAccount) {\n        lines.push({\n          id: generateId('jel'),\n          accountId: bankAccount.id,\n          accountCode: bankAccount.accountCode,\n          accountName: bankAccount.accountName,\n          description: `Payment ${payment.paymentNumber}`,\n          debit: payment.amount,\n          credit: 0,\n        })\n      }\n      \n      // Credit: Accounts Receivable\n      if (arAccount) {\n        lines.push({\n          id: generateId('jel'),\n          accountId: arAccount.id,\n          accountCode: arAccount.accountCode,\n          accountName: arAccount.accountName,\n          description: `Payment received for ${payment.invoiceNumber || 'invoice'}`,\n          debit: 0,\n          credit: payment.amount,\n        })\n      }\n      \n      const totalDebit = lines.reduce((sum, l) => sum + l.debit, 0)\n      const totalCredit = lines.reduce((sum, l) => sum + l.credit, 0)\n      \n      if (lines.length > 0 && totalDebit === totalCredit) {\n        try {\n          journalEntry = internalAccountingService.createJournalEntry(subAccountId, {\n            date: payment.date,\n            description: `Payment ${payment.paymentNumber} - ${payment.customerName}`,\n            reference: payment.paymentNumber,\n            referenceType: 'payment',\n            referenceId: payment.id,\n            lines,\n            status: autoPostJournalEntry ? 'posted' : 'draft',\n            totalDebit,\n            totalCredit,\n          })\n          \n          // Update payment with journal entry ID\n          payment.journalEntryId = journalEntry.id\n          const idx = payments.findIndex((p: AccountingPayment) => p.id === payment.id)\n          if (idx >= 0) {\n            payments[idx] = payment\n            setStorage(STORAGE_KEYS.payments, payments)\n          }\n          \n          // Update invoice paid amount if linked\n          if (payment.invoiceId) {\n            const invoices = getStorage(STORAGE_KEYS.invoices)\n            const invIdx = invoices.findIndex((i: AccountingInvoice) => \n              i.crmInvoiceId === payment.invoiceId || i.id === payment.invoiceId\n            )\n            if (invIdx >= 0) {\n              invoices[invIdx].amountPaid += payment.amount\n              invoices[invIdx].amountDue = Math.max(0, invoices[invIdx].total - invoices[invIdx].amountPaid)\n              if (invoices[invIdx].amountDue === 0) {\n                invoices[invIdx].status = 'paid'\n                invoices[invIdx].paidDate = now\n              } else if (invoices[invIdx].amountPaid > 0) {\n                invoices[invIdx].status = 'partial'\n              }\n              invoices[invIdx].updatedAt = now\n              setStorage(STORAGE_KEYS.invoices, invoices)\n            }\n          }\n        } catch (e) {\n          console.error('Failed to create journal entry:', e)\n        }\n      }\n    }\n    \n    return { payment, journalEntry }\n  },\n  \n  getPayments: (subAccountId: string, filters?: {\n    status?: string\n    method?: string\n    invoiceId?: string\n    startDate?: string\n    endDate?: string\n  }): AccountingPayment[] => {\n    let payments = getStorage(STORAGE_KEYS.payments)\n    payments = payments.filter((p: AccountingPayment) => p.subAccountId === subAccountId)\n    \n    if (filters?.status) {\n      payments = payments.filter((p: AccountingPayment) => p.status === filters.status)\n    }\n    if (filters?.method) {\n      payments = payments.filter((p: AccountingPayment) => p.method === filters.method)\n    }\n    if (filters?.invoiceId) {\n      payments = payments.filter((p: AccountingPayment) => p.invoiceId === filters.invoiceId)\n    }\n    if (filters?.startDate) {\n      payments = payments.filter((p: AccountingPayment) => p.date >= filters.startDate!)\n    }\n    if (filters?.endDate) {\n      payments = payments.filter((p: AccountingPayment) => p.date <= filters.endDate!)\n    }\n    \n    return payments.sort((a: AccountingPayment, b: AccountingPayment) => \n      new Date(b.date).getTime() - new Date(a.date).getTime()\n    )\n  },\n  \n  // -----------------------------------------\n  // FINANCIAL REPORTS\n  // -----------------------------------------\n  \n  getTrialBalance: (subAccountId: string): Array<{\n    accountCode: string\n    accountName: string\n    accountType: string\n    debit: number\n    credit: number\n  }> => {\n    const accounts = internalAccountingService.getGLAccounts(subAccountId)\n    \n    return accounts\n      .filter(a => a.balance !== 0)\n      .map(a => {\n        const isNormalDebitAccount = ['asset', 'expense', 'contra_liability', 'contra_equity', 'contra_revenue'].includes(a.accountType)\n        return {\n          accountCode: a.accountCode,\n          accountName: a.accountName,\n          accountType: a.accountType,\n          debit: isNormalDebitAccount && a.balance > 0 ? a.balance : (!isNormalDebitAccount && a.balance < 0 ? Math.abs(a.balance) : 0),\n          credit: !isNormalDebitAccount && a.balance > 0 ? a.balance : (isNormalDebitAccount && a.balance < 0 ? Math.abs(a.balance) : 0),\n        }\n      })\n      .sort((a, b) => a.accountCode.localeCompare(b.accountCode))\n  },\n  \n  getAccountsReceivableAging: (subAccountId: string): {\n    current: number\n    days30: number\n    days60: number\n    days90: number\n    days90Plus: number\n    total: number\n  } => {\n    const invoices = internalAccountingService.getInvoices(subAccountId)\n      .filter(i => i.amountDue > 0 && !['cancelled', 'void', 'draft'].includes(i.status))\n    \n    const now = new Date()\n    const aging = {\n      current: 0,\n      days30: 0,\n      days60: 0,\n      days90: 0,\n      days90Plus: 0,\n      total: 0,\n    }\n    \n    for (const invoice of invoices) {\n      const dueDate = new Date(invoice.dueDate)\n      const daysPastDue = Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24))\n      \n      if (daysPastDue <= 0) {\n        aging.current += invoice.amountDue\n      } else if (daysPastDue <= 30) {\n        aging.days30 += invoice.amountDue\n      } else if (daysPastDue <= 60) {\n        aging.days60 += invoice.amountDue\n      } else if (daysPastDue <= 90) {\n        aging.days90 += invoice.amountDue\n      } else {\n        aging.days90Plus += invoice.amountDue\n      }\n      aging.total += invoice.amountDue\n    }\n    \n    return aging\n  },\n}\n\n// ==========================================\n// SYNC QUEUE SERVICE\n// ==========================================\n\nexport const syncQueueService = {\n  addToQueue: (item: Omit<SyncQueueItem, 'id' | 'status' | 'attempts' | 'createdAt'>): SyncQueueItem => {\n    const queue = getStorage(STORAGE_KEYS.sync_queue)\n    \n    const newItem: SyncQueueItem = {\n      ...item,\n      id: generateId('sq'),\n      status: 'pending',\n      attempts: 0,\n      createdAt: new Date().toISOString(),\n    }\n    \n    setStorage(STORAGE_KEYS.sync_queue, [...queue, newItem])\n    return newItem\n  },\n  \n  getQueuedItems: (subAccountId?: string, status?: SyncQueueItem['status']): SyncQueueItem[] => {\n    let queue = getStorage(STORAGE_KEYS.sync_queue)\n    \n    if (subAccountId) {\n      queue = queue.filter((item: SyncQueueItem) => item.subAccountId === subAccountId)\n    }\n    if (status) {\n      queue = queue.filter((item: SyncQueueItem) => item.status === status)\n    }\n    \n    return queue.sort((a: SyncQueueItem, b: SyncQueueItem) => \n      new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n    )\n  },\n  \n  updateQueueItem: (itemId: string, updates: Partial<SyncQueueItem>): void => {\n    const queue = getStorage(STORAGE_KEYS.sync_queue)\n    const index = queue.findIndex((item: SyncQueueItem) => item.id === itemId)\n    \n    if (index >= 0) {\n      queue[index] = { ...queue[index], ...updates }\n      setStorage(STORAGE_KEYS.sync_queue, queue)\n    }\n  },\n  \n  processQueue: async (subAccountId: string): Promise<SyncResult[]> => {\n    const pendingItems = syncQueueService.getQueuedItems(subAccountId, 'pending')\n    const results: SyncResult[] = []\n    \n    for (const item of pendingItems) {\n      syncQueueService.updateQueueItem(item.id, { \n        status: 'processing',\n        attempts: item.attempts + 1,\n      })\n      \n      try {\n        // Process based on integration type\n        if (item.integrationType === 'internal') {\n          // Internal sync already handled real-time\n          syncQueueService.updateQueueItem(item.id, { \n            status: 'completed',\n            processedAt: new Date().toISOString(),\n          })\n          \n          results.push({\n            success: true,\n            entityType: item.entityType,\n            entityId: item.entityId,\n            action: item.action,\n            timestamp: new Date().toISOString(),\n          })\n        } else {\n          // External integrations would be handled here\n          // For now, mark as failed to retry later\n          throw new Error(`Integration type ${item.integrationType} not yet implemented`)\n        }\n      } catch (error: any) {\n        const shouldRetry = item.attempts < item.maxAttempts\n        \n        syncQueueService.updateQueueItem(item.id, {\n          status: shouldRetry ? 'pending' : 'failed',\n          lastError: error.message,\n          nextRetryAt: shouldRetry \n            ? new Date(Date.now() + Math.pow(2, item.attempts) * 60000).toISOString() // Exponential backoff\n            : undefined,\n        })\n        \n        results.push({\n          success: false,\n          entityType: item.entityType,\n          entityId: item.entityId,\n          action: item.action,\n          error: error.message,\n          timestamp: new Date().toISOString(),\n        })\n      }\n    }\n    \n    return results\n  },\n}\n\n// ==========================================\n// UNIFIED ACCOUNTING SYNC SERVICE\n// ==========================================\n\nexport const accountingSyncService = {\n  // Check if sub-account is Risivo Hub (uses internal sync)\n  isRisivoHub: (subAccountId: string): boolean => {\n    return subAccountId === RISIVO_HUB_SUB_ACCOUNT_ID || subAccountId.includes('risivo-hub')\n  },\n  \n  // Get integration config for sub-account\n  getIntegration: (subAccountId: string): AccountingIntegration | null => {\n    const integrations = getStorage(STORAGE_KEYS.integrations)\n    return integrations.find((i: AccountingIntegration) => \n      i.subAccountId === subAccountId && i.status === 'active'\n    ) || null\n  },\n  \n  // Initialize accounting for sub-account\n  initializeAccounting: (subAccountId: string, integrationType: IntegrationType = 'internal'): void => {\n    // Initialize GL accounts and tax codes\n    internalAccountingService.initializeChartOfAccounts(subAccountId)\n    internalAccountingService.initializeTaxCodes(subAccountId)\n    \n    // Create or update integration record\n    const integrations = getStorage(STORAGE_KEYS.integrations)\n    const existingIndex = integrations.findIndex((i: AccountingIntegration) => \n      i.subAccountId === subAccountId\n    )\n    \n    const now = new Date().toISOString()\n    const integration: AccountingIntegration = {\n      id: existingIndex >= 0 ? integrations[existingIndex].id : generateId('int'),\n      subAccountId,\n      type: integrationType,\n      status: 'active',\n      settings: {\n        syncCustomers: true,\n        syncInvoices: true,\n        syncPayments: true,\n        syncProducts: true,\n        autoPostJournalEntries: true,\n      },\n      createdAt: existingIndex >= 0 ? integrations[existingIndex].createdAt : now,\n      updatedAt: now,\n    }\n    \n    if (existingIndex >= 0) {\n      integrations[existingIndex] = integration\n    } else {\n      integrations.push(integration)\n    }\n    setStorage(STORAGE_KEYS.integrations, integrations)\n  },\n  \n  // Sync customer from CRM\n  syncCustomer: async (subAccountId: string, crmContact: any): Promise<SyncResult> => {\n    const integration = accountingSyncService.getIntegration(subAccountId)\n    \n    if (!integration || !integration.settings.syncCustomers) {\n      return {\n        success: false,\n        entityType: 'customer',\n        entityId: crmContact.id,\n        action: 'sync',\n        error: 'Customer sync not enabled',\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    if (integration.type === 'internal' || accountingSyncService.isRisivoHub(subAccountId)) {\n      const customer = internalAccountingService.syncCustomer(subAccountId, crmContact)\n      return {\n        success: true,\n        entityType: 'customer',\n        entityId: crmContact.id,\n        action: 'sync',\n        externalId: customer.id,\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    // Queue for external sync (QuickBooks/Xero)\n    syncQueueService.addToQueue({\n      subAccountId,\n      integrationType: integration.type,\n      entityType: 'customer',\n      entityId: crmContact.id,\n      action: 'sync',\n      payload: crmContact,\n      maxAttempts: 3,\n    })\n    \n    return {\n      success: true,\n      entityType: 'customer',\n      entityId: crmContact.id,\n      action: 'sync',\n      timestamp: new Date().toISOString(),\n    }\n  },\n  \n  // Sync invoice from CRM\n  syncInvoice: async (subAccountId: string, crmInvoice: any): Promise<SyncResult> => {\n    const integration = accountingSyncService.getIntegration(subAccountId)\n    \n    if (!integration || !integration.settings.syncInvoices) {\n      return {\n        success: false,\n        entityType: 'invoice',\n        entityId: crmInvoice.id,\n        action: 'sync',\n        error: 'Invoice sync not enabled',\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    if (integration.type === 'internal' || accountingSyncService.isRisivoHub(subAccountId)) {\n      const autoPost = integration.settings.autoPostJournalEntries\n      const { invoice } = internalAccountingService.syncInvoice(subAccountId, crmInvoice, autoPost)\n      return {\n        success: true,\n        entityType: 'invoice',\n        entityId: crmInvoice.id,\n        action: 'sync',\n        externalId: invoice.id,\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    // Queue for external sync\n    syncQueueService.addToQueue({\n      subAccountId,\n      integrationType: integration.type,\n      entityType: 'invoice',\n      entityId: crmInvoice.id,\n      action: 'sync',\n      payload: crmInvoice,\n      maxAttempts: 3,\n    })\n    \n    return {\n      success: true,\n      entityType: 'invoice',\n      entityId: crmInvoice.id,\n      action: 'sync',\n      timestamp: new Date().toISOString(),\n    }\n  },\n  \n  // Sync payment from CRM\n  syncPayment: async (subAccountId: string, crmPayment: any): Promise<SyncResult> => {\n    const integration = accountingSyncService.getIntegration(subAccountId)\n    \n    if (!integration || !integration.settings.syncPayments) {\n      return {\n        success: false,\n        entityType: 'payment',\n        entityId: crmPayment.id,\n        action: 'sync',\n        error: 'Payment sync not enabled',\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    if (integration.type === 'internal' || accountingSyncService.isRisivoHub(subAccountId)) {\n      const autoPost = integration.settings.autoPostJournalEntries\n      const { payment } = internalAccountingService.syncPayment(subAccountId, crmPayment, autoPost)\n      return {\n        success: true,\n        entityType: 'payment',\n        entityId: crmPayment.id,\n        action: 'sync',\n        externalId: payment.id,\n        timestamp: new Date().toISOString(),\n      }\n    }\n    \n    // Queue for external sync\n    syncQueueService.addToQueue({\n      subAccountId,\n      integrationType: integration.type,\n      entityType: 'payment',\n      entityId: crmPayment.id,\n      action: 'sync',\n      payload: crmPayment,\n      maxAttempts: 3,\n    })\n    \n    return {\n      success: true,\n      entityType: 'payment',\n      entityId: crmPayment.id,\n      action: 'sync',\n      timestamp: new Date().toISOString(),\n    }\n  },\n}\n\n// Export types for external use\nexport type {\n  AccountingCustomer,\n  AccountingInvoice,\n  AccountingPayment,\n  AccountingIntegration,\n  GLAccount,\n  JournalEntry,\n  TaxCode,\n  SyncQueueItem,\n  SyncResult,\n}\n","// QuickBooks Online Integration Service\n// For Client Sub-Accounts (Add-on: $20/month)\n\nimport type {\n  AccountingCustomer,\n  AccountingInvoice,\n  AccountingPayment,\n  SyncResult,\n  SyncEntityType,\n  SyncAction,\n} from './types'\n\n// ==========================================\n// QUICKBOOKS API CONFIGURATION\n// ==========================================\n\nconst QBO_ENDPOINTS = {\n  sandbox: 'https://sandbox-quickbooks.api.intuit.com',\n  production: 'https://quickbooks.api.intuit.com',\n}\n\ninterface QBOConfig {\n  clientId: string\n  clientSecret: string\n  redirectUri: string\n  environment: 'sandbox' | 'production'\n}\n\ninterface QBOTokens {\n  accessToken: string\n  refreshToken: string\n  expiresAt: string\n  realmId: string\n}\n\n// Storage key for QBO credentials (per sub-account)\nconst getQBOStorageKey = (subAccountId: string) => `qbo_tokens_${subAccountId}`\n\n// ==========================================\n// QUICKBOOKS OAUTH SERVICE\n// ==========================================\n\nexport const quickbooksOAuthService = {\n  // Generate OAuth authorization URL\n  getAuthorizationUrl: (config: QBOConfig, state: string): string => {\n    const baseUrl = 'https://appcenter.intuit.com/connect/oauth2'\n    const params = new URLSearchParams({\n      client_id: config.clientId,\n      redirect_uri: config.redirectUri,\n      response_type: 'code',\n      scope: 'com.intuit.quickbooks.accounting',\n      state,\n    })\n    return `${baseUrl}?${params.toString()}`\n  },\n\n  // Exchange authorization code for tokens\n  exchangeCodeForTokens: async (\n    config: QBOConfig,\n    code: string,\n    realmId: string\n  ): Promise<QBOTokens> => {\n    const tokenUrl = 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer'\n    \n    const response = await fetch(tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${btoa(`${config.clientId}:${config.clientSecret}`)}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: config.redirectUri,\n      }).toString(),\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(`Failed to exchange code: ${error.error_description || error.error}`)\n    }\n\n    const data = await response.json()\n    const expiresAt = new Date(Date.now() + data.expires_in * 1000).toISOString()\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt,\n      realmId,\n    }\n  },\n\n  // Refresh access token\n  refreshAccessToken: async (config: QBOConfig, refreshToken: string): Promise<QBOTokens> => {\n    const tokenUrl = 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer'\n    \n    const response = await fetch(tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${btoa(`${config.clientId}:${config.clientSecret}`)}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n      }).toString(),\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(`Failed to refresh token: ${error.error_description || error.error}`)\n    }\n\n    const data = await response.json()\n    const expiresAt = new Date(Date.now() + data.expires_in * 1000).toISOString()\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt,\n      realmId: '', // Will be set from stored value\n    }\n  },\n\n  // Store tokens (client-side)\n  storeTokens: (subAccountId: string, tokens: QBOTokens): void => {\n    if (typeof window === 'undefined') return\n    localStorage.setItem(getQBOStorageKey(subAccountId), JSON.stringify(tokens))\n  },\n\n  // Get stored tokens\n  getTokens: (subAccountId: string): QBOTokens | null => {\n    if (typeof window === 'undefined') return null\n    try {\n      const data = localStorage.getItem(getQBOStorageKey(subAccountId))\n      return data ? JSON.parse(data) : null\n    } catch {\n      return null\n    }\n  },\n\n  // Check if tokens need refresh\n  needsRefresh: (tokens: QBOTokens): boolean => {\n    const expiresAt = new Date(tokens.expiresAt).getTime()\n    const now = Date.now()\n    // Refresh if within 5 minutes of expiration\n    return (expiresAt - now) < 5 * 60 * 1000\n  },\n\n  // Clear tokens\n  clearTokens: (subAccountId: string): void => {\n    if (typeof window === 'undefined') return\n    localStorage.removeItem(getQBOStorageKey(subAccountId))\n  },\n}\n\n// ==========================================\n// QUICKBOOKS API SERVICE\n// ==========================================\n\nclass QuickBooksAPIService {\n  private config: QBOConfig\n  private subAccountId: string\n\n  constructor(config: QBOConfig, subAccountId: string) {\n    this.config = config\n    this.subAccountId = subAccountId\n  }\n\n  // Get valid access token (refresh if needed)\n  private async getAccessToken(): Promise<string> {\n    let tokens = quickbooksOAuthService.getTokens(this.subAccountId)\n    \n    if (!tokens) {\n      throw new Error('QuickBooks not connected. Please authenticate first.')\n    }\n\n    if (quickbooksOAuthService.needsRefresh(tokens)) {\n      const refreshedTokens = await quickbooksOAuthService.refreshAccessToken(\n        this.config,\n        tokens.refreshToken\n      )\n      refreshedTokens.realmId = tokens.realmId\n      quickbooksOAuthService.storeTokens(this.subAccountId, refreshedTokens)\n      tokens = refreshedTokens\n    }\n\n    return tokens.accessToken\n  }\n\n  // Get realm ID\n  private getRealmId(): string {\n    const tokens = quickbooksOAuthService.getTokens(this.subAccountId)\n    if (!tokens?.realmId) {\n      throw new Error('QuickBooks realm ID not found')\n    }\n    return tokens.realmId\n  }\n\n  // Base API URL\n  private get baseUrl(): string {\n    return `${QBO_ENDPOINTS[this.config.environment]}/v3/company/${this.getRealmId()}`\n  }\n\n  // Make authenticated API request\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET',\n    body?: any\n  ): Promise<T> {\n    const accessToken = await this.getAccessToken()\n\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      method,\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(error.Fault?.Error?.[0]?.Detail || 'QuickBooks API error')\n    }\n\n    return response.json()\n  }\n\n  // -----------------------------------------\n  // CUSTOMER OPERATIONS\n  // -----------------------------------------\n\n  async createCustomer(customer: AccountingCustomer): Promise<any> {\n    const qboCustomer = {\n      DisplayName: customer.companyName,\n      CompanyName: customer.companyName,\n      PrimaryEmailAddr: customer.billingEmail ? { Address: customer.billingEmail } : undefined,\n      PrimaryPhone: customer.phone ? { FreeFormNumber: customer.phone } : undefined,\n      BillAddr: customer.address ? {\n        Line1: customer.address,\n        City: customer.city,\n        CountrySubDivisionCode: customer.state,\n        PostalCode: customer.postalCode,\n        Country: customer.country,\n      } : undefined,\n      GivenName: customer.contactPerson?.split(' ')[0],\n      FamilyName: customer.contactPerson?.split(' ').slice(1).join(' '),\n      Notes: `CRM Contact ID: ${customer.crmContactId}`,\n    }\n\n    const result = await this.request<any>('/customer', 'POST', qboCustomer)\n    return result.Customer\n  }\n\n  async updateCustomer(qboId: string, syncToken: string, customer: AccountingCustomer): Promise<any> {\n    const qboCustomer = {\n      Id: qboId,\n      SyncToken: syncToken,\n      DisplayName: customer.companyName,\n      CompanyName: customer.companyName,\n      PrimaryEmailAddr: customer.billingEmail ? { Address: customer.billingEmail } : undefined,\n      PrimaryPhone: customer.phone ? { FreeFormNumber: customer.phone } : undefined,\n    }\n\n    const result = await this.request<any>('/customer', 'POST', qboCustomer)\n    return result.Customer\n  }\n\n  async findCustomerByName(displayName: string): Promise<any | null> {\n    const query = encodeURIComponent(`SELECT * FROM Customer WHERE DisplayName = '${displayName}'`)\n    const result = await this.request<any>(`/query?query=${query}`)\n    return result.QueryResponse?.Customer?.[0] || null\n  }\n\n  // -----------------------------------------\n  // INVOICE OPERATIONS\n  // -----------------------------------------\n\n  async createInvoice(invoice: AccountingInvoice, qboCustomerId: string): Promise<any> {\n    const qboInvoice = {\n      CustomerRef: { value: qboCustomerId },\n      TxnDate: invoice.issueDate.split('T')[0],\n      DueDate: invoice.dueDate.split('T')[0],\n      Line: invoice.items.map((item, idx) => ({\n        DetailType: 'SalesItemLineDetail',\n        Amount: item.amount,\n        Description: item.description,\n        SalesItemLineDetail: {\n          Qty: item.quantity,\n          UnitPrice: item.unitPrice,\n          // ItemRef would need to map to QBO item\n        },\n        LineNum: idx + 1,\n      })),\n      CustomerMemo: invoice.notes ? { value: invoice.notes } : undefined,\n      PrivateNote: `CRM Invoice ID: ${invoice.crmInvoiceId}`,\n    }\n\n    const result = await this.request<any>('/invoice', 'POST', qboInvoice)\n    return result.Invoice\n  }\n\n  async findInvoiceByDocNumber(docNumber: string): Promise<any | null> {\n    const query = encodeURIComponent(`SELECT * FROM Invoice WHERE DocNumber = '${docNumber}'`)\n    const result = await this.request<any>(`/query?query=${query}`)\n    return result.QueryResponse?.Invoice?.[0] || null\n  }\n\n  // -----------------------------------------\n  // PAYMENT OPERATIONS\n  // -----------------------------------------\n\n  async createPayment(payment: AccountingPayment, qboCustomerId: string, qboInvoiceId?: string): Promise<any> {\n    const qboPayment: any = {\n      CustomerRef: { value: qboCustomerId },\n      TotalAmt: payment.amount,\n      TxnDate: payment.date.split('T')[0],\n      PrivateNote: `CRM Payment ID: ${payment.crmPaymentId}`,\n    }\n\n    if (qboInvoiceId) {\n      qboPayment.Line = [{\n        Amount: payment.amount,\n        LinkedTxn: [{\n          TxnId: qboInvoiceId,\n          TxnType: 'Invoice',\n        }],\n      }]\n    }\n\n    // Map payment method to QBO payment method\n    const methodMap: Record<string, string> = {\n      credit_card: 'Credit Card',\n      bank_transfer: 'Bank Transfer',\n      check: 'Check',\n      cash: 'Cash',\n      paypal: 'PayPal',\n      stripe: 'Credit Card',\n    }\n    \n    qboPayment.PaymentMethodRef = {\n      name: methodMap[payment.method] || 'Other',\n    }\n\n    const result = await this.request<any>('/payment', 'POST', qboPayment)\n    return result.Payment\n  }\n\n  // -----------------------------------------\n  // PRODUCT/ITEM OPERATIONS\n  // -----------------------------------------\n\n  async createItem(product: any): Promise<any> {\n    const qboItem = {\n      Name: product.name,\n      Description: product.description,\n      Type: product.type === 'service' ? 'Service' : 'NonInventory',\n      UnitPrice: product.price,\n      IncomeAccountRef: { value: '1' }, // Default income account\n      Taxable: product.taxable ?? true,\n    }\n\n    const result = await this.request<any>('/item', 'POST', qboItem)\n    return result.Item\n  }\n\n  async findItemByName(name: string): Promise<any | null> {\n    const query = encodeURIComponent(`SELECT * FROM Item WHERE Name = '${name}'`)\n    const result = await this.request<any>(`/query?query=${query}`)\n    return result.QueryResponse?.Item?.[0] || null\n  }\n}\n\n// ==========================================\n// QUICKBOOKS SYNC SERVICE\n// ==========================================\n\nexport const quickbooksSyncService = {\n  // Create API service instance\n  createService: (config: QBOConfig, subAccountId: string): QuickBooksAPIService => {\n    return new QuickBooksAPIService(config, subAccountId)\n  },\n\n  // Sync customer to QuickBooks\n  syncCustomer: async (\n    service: QuickBooksAPIService,\n    customer: AccountingCustomer\n  ): Promise<SyncResult> => {\n    try {\n      // Check if customer exists\n      const existing = await service.findCustomerByName(customer.companyName)\n\n      let qboCustomer: any\n      if (existing) {\n        // Update existing\n        qboCustomer = await service.updateCustomer(existing.Id, existing.SyncToken, customer)\n      } else {\n        // Create new\n        qboCustomer = await service.createCustomer(customer)\n      }\n\n      return {\n        success: true,\n        entityType: 'customer',\n        entityId: customer.id,\n        action: existing ? 'update' : 'create',\n        externalId: qboCustomer.Id,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'customer',\n        entityId: customer.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n\n  // Sync invoice to QuickBooks\n  syncInvoice: async (\n    service: QuickBooksAPIService,\n    invoice: AccountingInvoice,\n    qboCustomerId: string\n  ): Promise<SyncResult> => {\n    try {\n      // Check if invoice exists\n      const existing = await service.findInvoiceByDocNumber(invoice.invoiceNumber)\n\n      if (existing) {\n        // Invoice already exists - can't easily update in QBO\n        return {\n          success: true,\n          entityType: 'invoice',\n          entityId: invoice.id,\n          action: 'sync',\n          externalId: existing.Id,\n          timestamp: new Date().toISOString(),\n        }\n      }\n\n      const qboInvoice = await service.createInvoice(invoice, qboCustomerId)\n\n      return {\n        success: true,\n        entityType: 'invoice',\n        entityId: invoice.id,\n        action: 'create',\n        externalId: qboInvoice.Id,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'invoice',\n        entityId: invoice.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n\n  // Sync payment to QuickBooks\n  syncPayment: async (\n    service: QuickBooksAPIService,\n    payment: AccountingPayment,\n    qboCustomerId: string,\n    qboInvoiceId?: string\n  ): Promise<SyncResult> => {\n    try {\n      const qboPayment = await service.createPayment(payment, qboCustomerId, qboInvoiceId)\n\n      return {\n        success: true,\n        entityType: 'payment',\n        entityId: payment.id,\n        action: 'create',\n        externalId: qboPayment.Id,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'payment',\n        entityId: payment.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n}\n\n// ==========================================\n// CONNECTION STATUS HELPERS\n// ==========================================\n\nexport const quickbooksConnectionStatus = {\n  isConnected: (subAccountId: string): boolean => {\n    const tokens = quickbooksOAuthService.getTokens(subAccountId)\n    return tokens !== null && tokens.accessToken !== ''\n  },\n\n  getConnectionInfo: (subAccountId: string): {\n    connected: boolean\n    realmId?: string\n    expiresAt?: string\n  } => {\n    const tokens = quickbooksOAuthService.getTokens(subAccountId)\n    if (!tokens) {\n      return { connected: false }\n    }\n    return {\n      connected: true,\n      realmId: tokens.realmId,\n      expiresAt: tokens.expiresAt,\n    }\n  },\n\n  disconnect: (subAccountId: string): void => {\n    quickbooksOAuthService.clearTokens(subAccountId)\n  },\n}\n\n// Export types\nexport type { QBOConfig, QBOTokens }\n","// Xero Integration Service\n// For Client Sub-Accounts (Add-on: $20/month)\n\nimport type {\n  AccountingCustomer,\n  AccountingInvoice,\n  AccountingPayment,\n  SyncResult,\n} from './types'\n\n// ==========================================\n// XERO API CONFIGURATION\n// ==========================================\n\nconst XERO_ENDPOINTS = {\n  auth: 'https://identity.xero.com',\n  api: 'https://api.xero.com/api.xro/2.0',\n}\n\ninterface XeroConfig {\n  clientId: string\n  clientSecret: string\n  redirectUri: string\n  scopes: string[]\n}\n\ninterface XeroTokens {\n  accessToken: string\n  refreshToken: string\n  expiresAt: string\n  tenantId: string // Xero organization ID\n  tenantName?: string\n}\n\n// Default scopes for accounting integration\nconst DEFAULT_SCOPES = [\n  'openid',\n  'profile',\n  'email',\n  'accounting.transactions',\n  'accounting.contacts',\n  'accounting.settings.read',\n  'offline_access',\n]\n\n// Storage key for Xero credentials (per sub-account)\nconst getXeroStorageKey = (subAccountId: string) => `xero_tokens_${subAccountId}`\n\n// ==========================================\n// XERO OAUTH SERVICE\n// ==========================================\n\nexport const xeroOAuthService = {\n  // Generate OAuth authorization URL\n  getAuthorizationUrl: (config: XeroConfig, state: string): string => {\n    const scopes = config.scopes.length > 0 ? config.scopes : DEFAULT_SCOPES\n    const params = new URLSearchParams({\n      response_type: 'code',\n      client_id: config.clientId,\n      redirect_uri: config.redirectUri,\n      scope: scopes.join(' '),\n      state,\n    })\n    return `${XERO_ENDPOINTS.auth}/connect/authorize?${params.toString()}`\n  },\n\n  // Exchange authorization code for tokens\n  exchangeCodeForTokens: async (\n    config: XeroConfig,\n    code: string\n  ): Promise<XeroTokens> => {\n    const tokenUrl = `${XERO_ENDPOINTS.auth}/connect/token`\n\n    const response = await fetch(tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${btoa(`${config.clientId}:${config.clientSecret}`)}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: config.redirectUri,\n      }).toString(),\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(`Failed to exchange code: ${error.error_description || error.error}`)\n    }\n\n    const data = await response.json()\n    const expiresAt = new Date(Date.now() + data.expires_in * 1000).toISOString()\n\n    // Get tenant (organization) connections\n    const connectionsResponse = await fetch('https://api.xero.com/connections', {\n      headers: {\n        'Authorization': `Bearer ${data.access_token}`,\n        'Content-Type': 'application/json',\n      },\n    })\n\n    const connections = await connectionsResponse.json()\n    const tenant = connections[0] // Use first connected organization\n\n    if (!tenant) {\n      throw new Error('No Xero organization connected')\n    }\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt,\n      tenantId: tenant.tenantId,\n      tenantName: tenant.tenantName,\n    }\n  },\n\n  // Refresh access token\n  refreshAccessToken: async (config: XeroConfig, refreshToken: string): Promise<Omit<XeroTokens, 'tenantId' | 'tenantName'>> => {\n    const tokenUrl = `${XERO_ENDPOINTS.auth}/connect/token`\n\n    const response = await fetch(tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${btoa(`${config.clientId}:${config.clientSecret}`)}`,\n      },\n      body: new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n      }).toString(),\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(`Failed to refresh token: ${error.error_description || error.error}`)\n    }\n\n    const data = await response.json()\n    const expiresAt = new Date(Date.now() + data.expires_in * 1000).toISOString()\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt,\n    }\n  },\n\n  // Store tokens (client-side)\n  storeTokens: (subAccountId: string, tokens: XeroTokens): void => {\n    if (typeof window === 'undefined') return\n    localStorage.setItem(getXeroStorageKey(subAccountId), JSON.stringify(tokens))\n  },\n\n  // Get stored tokens\n  getTokens: (subAccountId: string): XeroTokens | null => {\n    if (typeof window === 'undefined') return null\n    try {\n      const data = localStorage.getItem(getXeroStorageKey(subAccountId))\n      return data ? JSON.parse(data) : null\n    } catch {\n      return null\n    }\n  },\n\n  // Check if tokens need refresh\n  needsRefresh: (tokens: XeroTokens): boolean => {\n    const expiresAt = new Date(tokens.expiresAt).getTime()\n    const now = Date.now()\n    // Refresh if within 5 minutes of expiration\n    return (expiresAt - now) < 5 * 60 * 1000\n  },\n\n  // Clear tokens\n  clearTokens: (subAccountId: string): void => {\n    if (typeof window === 'undefined') return\n    localStorage.removeItem(getXeroStorageKey(subAccountId))\n  },\n}\n\n// ==========================================\n// XERO API SERVICE\n// ==========================================\n\nclass XeroAPIService {\n  private config: XeroConfig\n  private subAccountId: string\n\n  constructor(config: XeroConfig, subAccountId: string) {\n    this.config = config\n    this.subAccountId = subAccountId\n  }\n\n  // Get valid access token (refresh if needed)\n  private async getAccessToken(): Promise<string> {\n    let tokens = xeroOAuthService.getTokens(this.subAccountId)\n\n    if (!tokens) {\n      throw new Error('Xero not connected. Please authenticate first.')\n    }\n\n    if (xeroOAuthService.needsRefresh(tokens)) {\n      const refreshedTokens = await xeroOAuthService.refreshAccessToken(\n        this.config,\n        tokens.refreshToken\n      )\n      const updatedTokens: XeroTokens = {\n        ...refreshedTokens,\n        tenantId: tokens.tenantId,\n        tenantName: tokens.tenantName,\n      }\n      xeroOAuthService.storeTokens(this.subAccountId, updatedTokens)\n      tokens = updatedTokens\n    }\n\n    return tokens.accessToken\n  }\n\n  // Get tenant ID\n  private getTenantId(): string {\n    const tokens = xeroOAuthService.getTokens(this.subAccountId)\n    if (!tokens?.tenantId) {\n      throw new Error('Xero tenant ID not found')\n    }\n    return tokens.tenantId\n  }\n\n  // Make authenticated API request\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' = 'GET',\n    body?: any\n  ): Promise<T> {\n    const accessToken = await this.getAccessToken()\n    const tenantId = this.getTenantId()\n\n    const response = await fetch(`${XERO_ENDPOINTS.api}${endpoint}`, {\n      method,\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'xero-tenant-id': tenantId,\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(error.Message || error.Detail || 'Xero API error')\n    }\n\n    return response.json()\n  }\n\n  // -----------------------------------------\n  // CONTACT OPERATIONS\n  // -----------------------------------------\n\n  async createContact(customer: AccountingCustomer): Promise<any> {\n    const xeroContact = {\n      Contacts: [{\n        Name: customer.companyName,\n        FirstName: customer.contactPerson?.split(' ')[0],\n        LastName: customer.contactPerson?.split(' ').slice(1).join(' '),\n        EmailAddress: customer.billingEmail,\n        Phones: customer.phone ? [{\n          PhoneType: 'DEFAULT',\n          PhoneNumber: customer.phone,\n        }] : [],\n        Addresses: customer.address ? [{\n          AddressType: 'STREET',\n          AddressLine1: customer.address,\n          City: customer.city,\n          Region: customer.state,\n          PostalCode: customer.postalCode,\n          Country: customer.country,\n        }] : [],\n        TaxNumber: customer.taxId,\n        DefaultCurrency: customer.currency || 'USD',\n        ContactStatus: customer.status === 'active' ? 'ACTIVE' : 'ARCHIVED',\n      }],\n    }\n\n    const result = await this.request<any>('/Contacts', 'POST', xeroContact)\n    return result.Contacts?.[0]\n  }\n\n  async updateContact(xeroContactId: string, customer: AccountingCustomer): Promise<any> {\n    const xeroContact = {\n      Contacts: [{\n        ContactID: xeroContactId,\n        Name: customer.companyName,\n        FirstName: customer.contactPerson?.split(' ')[0],\n        LastName: customer.contactPerson?.split(' ').slice(1).join(' '),\n        EmailAddress: customer.billingEmail,\n        Phones: customer.phone ? [{\n          PhoneType: 'DEFAULT',\n          PhoneNumber: customer.phone,\n        }] : [],\n      }],\n    }\n\n    const result = await this.request<any>('/Contacts', 'POST', xeroContact)\n    return result.Contacts?.[0]\n  }\n\n  async findContactByName(name: string): Promise<any | null> {\n    try {\n      const result = await this.request<any>(`/Contacts?where=Name==\"${encodeURIComponent(name)}\"`)\n      return result.Contacts?.[0] || null\n    } catch {\n      return null\n    }\n  }\n\n  async findContactByEmail(email: string): Promise<any | null> {\n    try {\n      const result = await this.request<any>(`/Contacts?where=EmailAddress==\"${encodeURIComponent(email)}\"`)\n      return result.Contacts?.[0] || null\n    } catch {\n      return null\n    }\n  }\n\n  // -----------------------------------------\n  // INVOICE OPERATIONS\n  // -----------------------------------------\n\n  async createInvoice(invoice: AccountingInvoice, xeroContactId: string): Promise<any> {\n    const xeroInvoice = {\n      Invoices: [{\n        Type: 'ACCREC', // Accounts Receivable\n        Contact: { ContactID: xeroContactId },\n        Date: invoice.issueDate.split('T')[0],\n        DueDate: invoice.dueDate.split('T')[0],\n        LineAmountTypes: invoice.taxAmount > 0 ? 'Inclusive' : 'NoTax',\n        InvoiceNumber: invoice.invoiceNumber,\n        Reference: `CRM: ${invoice.crmInvoiceId}`,\n        Status: this.mapInvoiceStatus(invoice.status),\n        CurrencyCode: invoice.currency || 'USD',\n        LineItems: invoice.items.map(item => ({\n          Description: item.description,\n          Quantity: item.quantity,\n          UnitAmount: item.unitPrice,\n          TaxType: item.taxRate ? 'OUTPUT' : 'NONE',\n          AccountCode: '200', // Default sales account\n        })),\n      }],\n    }\n\n    const result = await this.request<any>('/Invoices', 'POST', xeroInvoice)\n    return result.Invoices?.[0]\n  }\n\n  private mapInvoiceStatus(status: AccountingInvoice['status']): string {\n    const statusMap: Record<string, string> = {\n      draft: 'DRAFT',\n      sent: 'AUTHORISED',\n      viewed: 'AUTHORISED',\n      partial: 'AUTHORISED',\n      paid: 'PAID',\n      overdue: 'AUTHORISED',\n      cancelled: 'VOIDED',\n      void: 'VOIDED',\n    }\n    return statusMap[status] || 'DRAFT'\n  }\n\n  async findInvoiceByNumber(invoiceNumber: string): Promise<any | null> {\n    try {\n      const result = await this.request<any>(`/Invoices?InvoiceNumbers=${encodeURIComponent(invoiceNumber)}`)\n      return result.Invoices?.[0] || null\n    } catch {\n      return null\n    }\n  }\n\n  // -----------------------------------------\n  // PAYMENT OPERATIONS\n  // -----------------------------------------\n\n  async createPayment(payment: AccountingPayment, xeroInvoiceId: string, xeroAccountId: string): Promise<any> {\n    const xeroPayment = {\n      Payments: [{\n        Invoice: { InvoiceID: xeroInvoiceId },\n        Account: { AccountID: xeroAccountId },\n        Date: payment.date.split('T')[0],\n        Amount: payment.amount,\n        Reference: payment.reference || `CRM: ${payment.crmPaymentId}`,\n        CurrencyRate: 1,\n      }],\n    }\n\n    const result = await this.request<any>('/Payments', 'POST', xeroPayment)\n    return result.Payments?.[0]\n  }\n\n  // -----------------------------------------\n  // ACCOUNT OPERATIONS\n  // -----------------------------------------\n\n  async getBankAccounts(): Promise<any[]> {\n    const result = await this.request<any>('/Accounts?where=Type==\"BANK\"')\n    return result.Accounts || []\n  }\n\n  async getRevenueAccounts(): Promise<any[]> {\n    const result = await this.request<any>('/Accounts?where=Type==\"REVENUE\"')\n    return result.Accounts || []\n  }\n\n  // -----------------------------------------\n  // ITEM OPERATIONS\n  // -----------------------------------------\n\n  async createItem(product: any): Promise<any> {\n    const xeroItem = {\n      Items: [{\n        Code: product.sku || product.id,\n        Name: product.name,\n        Description: product.description,\n        IsSold: true,\n        IsPurchased: false,\n        SalesDetails: {\n          UnitPrice: product.price,\n          AccountCode: '200', // Default sales account\n          TaxType: product.taxable ? 'OUTPUT' : 'NONE',\n        },\n      }],\n    }\n\n    const result = await this.request<any>('/Items', 'POST', xeroItem)\n    return result.Items?.[0]\n  }\n\n  async findItemByCode(code: string): Promise<any | null> {\n    try {\n      const result = await this.request<any>(`/Items/${encodeURIComponent(code)}`)\n      return result.Items?.[0] || null\n    } catch {\n      return null\n    }\n  }\n}\n\n// ==========================================\n// XERO SYNC SERVICE\n// ==========================================\n\nexport const xeroSyncService = {\n  // Create API service instance\n  createService: (config: XeroConfig, subAccountId: string): XeroAPIService => {\n    return new XeroAPIService(config, subAccountId)\n  },\n\n  // Sync customer to Xero\n  syncContact: async (\n    service: XeroAPIService,\n    customer: AccountingCustomer\n  ): Promise<SyncResult> => {\n    try {\n      // Try to find existing contact by name or email\n      let existing = await service.findContactByName(customer.companyName)\n      if (!existing && customer.billingEmail) {\n        existing = await service.findContactByEmail(customer.billingEmail)\n      }\n\n      let xeroContact: any\n      if (existing) {\n        // Update existing\n        xeroContact = await service.updateContact(existing.ContactID, customer)\n      } else {\n        // Create new\n        xeroContact = await service.createContact(customer)\n      }\n\n      return {\n        success: true,\n        entityType: 'customer',\n        entityId: customer.id,\n        action: existing ? 'update' : 'create',\n        externalId: xeroContact?.ContactID,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'customer',\n        entityId: customer.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n\n  // Sync invoice to Xero\n  syncInvoice: async (\n    service: XeroAPIService,\n    invoice: AccountingInvoice,\n    xeroContactId: string\n  ): Promise<SyncResult> => {\n    try {\n      // Check if invoice exists\n      const existing = await service.findInvoiceByNumber(invoice.invoiceNumber)\n\n      if (existing) {\n        // Invoice already exists in Xero\n        return {\n          success: true,\n          entityType: 'invoice',\n          entityId: invoice.id,\n          action: 'sync',\n          externalId: existing.InvoiceID,\n          timestamp: new Date().toISOString(),\n        }\n      }\n\n      const xeroInvoice = await service.createInvoice(invoice, xeroContactId)\n\n      return {\n        success: true,\n        entityType: 'invoice',\n        entityId: invoice.id,\n        action: 'create',\n        externalId: xeroInvoice?.InvoiceID,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'invoice',\n        entityId: invoice.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n\n  // Sync payment to Xero\n  syncPayment: async (\n    service: XeroAPIService,\n    payment: AccountingPayment,\n    xeroInvoiceId: string,\n    xeroAccountId: string\n  ): Promise<SyncResult> => {\n    try {\n      const xeroPayment = await service.createPayment(payment, xeroInvoiceId, xeroAccountId)\n\n      return {\n        success: true,\n        entityType: 'payment',\n        entityId: payment.id,\n        action: 'create',\n        externalId: xeroPayment?.PaymentID,\n        timestamp: new Date().toISOString(),\n      }\n    } catch (error: any) {\n      return {\n        success: false,\n        entityType: 'payment',\n        entityId: payment.id,\n        action: 'sync',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }\n    }\n  },\n}\n\n// ==========================================\n// CONNECTION STATUS HELPERS\n// ==========================================\n\nexport const xeroConnectionStatus = {\n  isConnected: (subAccountId: string): boolean => {\n    const tokens = xeroOAuthService.getTokens(subAccountId)\n    return tokens !== null && tokens.accessToken !== ''\n  },\n\n  getConnectionInfo: (subAccountId: string): {\n    connected: boolean\n    tenantId?: string\n    tenantName?: string\n    expiresAt?: string\n  } => {\n    const tokens = xeroOAuthService.getTokens(subAccountId)\n    if (!tokens) {\n      return { connected: false }\n    }\n    return {\n      connected: true,\n      tenantId: tokens.tenantId,\n      tenantName: tokens.tenantName,\n      expiresAt: tokens.expiresAt,\n    }\n  },\n\n  disconnect: (subAccountId: string): void => {\n    xeroOAuthService.clearTokens(subAccountId)\n  },\n}\n\n// Export types\nexport type { XeroConfig, XeroTokens }\n","// Accounting Module Index\n// Exports all accounting integration services and types\n\n// Core types\nexport * from './types'\n\n// Internal accounting service (for Risivo Hub)\nexport {\n  internalAccountingService,\n  syncQueueService,\n  accountingSyncService,\n} from './integration'\n\n// QuickBooks Online integration (for client sub-accounts)\nexport {\n  quickbooksOAuthService,\n  quickbooksSyncService,\n  quickbooksConnectionStatus,\n} from './quickbooks'\nexport type { QBOConfig, QBOTokens } from './quickbooks'\n\n// Xero integration (for client sub-accounts)\nexport {\n  xeroOAuthService,\n  xeroSyncService,\n  xeroConnectionStatus,\n} from './xero'\nexport type { XeroConfig, XeroTokens } from './xero'\n\n// React hooks\nexport {\n  useAccountingInit,\n  useGLAccounts,\n  useJournalEntries,\n  useTaxCodes,\n  useAccountingSync,\n  useSyncQueue,\n  useTrialBalance,\n  useARaging,\n  useAccountingInvoices,\n  useAccountingPayments,\n  useAccountingCustomers,\n  useAccountingIntegration,\n} from './hooks'\n\n// ==========================================\n// UNIFIED ACCOUNTING API\n// ==========================================\n\nimport { accountingSyncService, internalAccountingService } from './integration'\nimport { quickbooksConnectionStatus, quickbooksSyncService } from './quickbooks'\nimport { xeroConnectionStatus, xeroSyncService } from './xero'\nimport type {\n  IntegrationType,\n  AccountingIntegration,\n  AccountingCustomer,\n  AccountingInvoice,\n  AccountingPayment,\n  GLAccount,\n  JournalEntry,\n  TaxCode,\n  SyncResult,\n} from './types'\nimport { RISIVO_HUB_SUB_ACCOUNT_ID } from './types'\n\n/**\n * Unified Accounting API\n * \n * Automatically routes to the correct integration based on sub-account:\n * - Risivo Hub â†’ Internal (localStorage-based accounting)\n * - Client Sub-Accounts â†’ QuickBooks Online or Xero (based on configured integration)\n */\nexport const accountingAPI = {\n  /**\n   * Check if accounting is configured for a sub-account\n   */\n  isConfigured: (subAccountId: string): boolean => {\n    // Risivo Hub always has internal accounting\n    if (accountingSyncService.isRisivoHub(subAccountId)) {\n      return true\n    }\n    // Check for external integrations\n    return (\n      quickbooksConnectionStatus.isConnected(subAccountId) ||\n      xeroConnectionStatus.isConnected(subAccountId)\n    )\n  },\n\n  /**\n   * Get active integration type for sub-account\n   */\n  getIntegrationType: (subAccountId: string): IntegrationType | null => {\n    if (accountingSyncService.isRisivoHub(subAccountId)) {\n      return 'internal'\n    }\n    if (quickbooksConnectionStatus.isConnected(subAccountId)) {\n      return 'quickbooks'\n    }\n    if (xeroConnectionStatus.isConnected(subAccountId)) {\n      return 'xero'\n    }\n    return null\n  },\n\n  /**\n   * Initialize accounting for a sub-account\n   */\n  initialize: (subAccountId: string, integrationType: IntegrationType = 'internal'): void => {\n    accountingSyncService.initializeAccounting(subAccountId, integrationType)\n  },\n\n  /**\n   * Get Chart of Accounts (GL Accounts)\n   */\n  getChartOfAccounts: (subAccountId: string): GLAccount[] => {\n    return internalAccountingService.getGLAccounts(subAccountId)\n  },\n\n  /**\n   * Get Tax Codes\n   */\n  getTaxCodes: (subAccountId: string): TaxCode[] => {\n    return internalAccountingService.getTaxCodes(subAccountId)\n  },\n\n  /**\n   * Get Journal Entries\n   */\n  getJournalEntries: (subAccountId: string, filters?: {\n    status?: string\n    referenceType?: string\n    startDate?: string\n    endDate?: string\n  }): JournalEntry[] => {\n    return internalAccountingService.getJournalEntries(subAccountId, filters)\n  },\n\n  /**\n   * Sync customer to accounting\n   */\n  syncCustomer: async (subAccountId: string, contact: {\n    id: string\n    name: string\n    email: string\n    company?: string\n    phone?: string\n    address?: string\n  }): Promise<SyncResult> => {\n    return accountingSyncService.syncCustomer(subAccountId, contact)\n  },\n\n  /**\n   * Sync invoice to accounting\n   */\n  syncInvoice: async (subAccountId: string, invoice: {\n    id: string\n    invoiceNumber?: string\n    contactId?: string\n    contactName?: string\n    contactEmail?: string\n    items: Array<{\n      description: string\n      quantity: number\n      unitPrice: number\n      taxRate?: number\n    }>\n    subtotal: number\n    taxAmount: number\n    discountAmount?: number\n    total: number\n    status: string\n    issueDate: string\n    dueDate: string\n    notes?: string\n  }): Promise<SyncResult> => {\n    return accountingSyncService.syncInvoice(subAccountId, invoice)\n  },\n\n  /**\n   * Sync payment to accounting\n   */\n  syncPayment: async (subAccountId: string, payment: {\n    id: string\n    paymentNumber?: string\n    invoiceId?: string\n    invoiceNumber?: string\n    contactId?: string\n    contactName?: string\n    amount: number\n    method: string\n    status: string\n    date: string\n    reference?: string\n    notes?: string\n    gatewayId?: string\n    gateway?: string\n  }): Promise<SyncResult> => {\n    return accountingSyncService.syncPayment(subAccountId, payment)\n  },\n\n  /**\n   * Get accounting customers\n   */\n  getCustomers: (subAccountId: string): AccountingCustomer[] => {\n    return internalAccountingService.getCustomers(subAccountId)\n  },\n\n  /**\n   * Get accounting invoices\n   */\n  getInvoices: (subAccountId: string, filters?: {\n    status?: string\n    customerId?: string\n    startDate?: string\n    endDate?: string\n  }): AccountingInvoice[] => {\n    return internalAccountingService.getInvoices(subAccountId, filters)\n  },\n\n  /**\n   * Get accounting payments\n   */\n  getPayments: (subAccountId: string, filters?: {\n    status?: string\n    method?: string\n    invoiceId?: string\n    startDate?: string\n    endDate?: string\n  }): AccountingPayment[] => {\n    return internalAccountingService.getPayments(subAccountId, filters)\n  },\n\n  /**\n   * Get Trial Balance\n   */\n  getTrialBalance: (subAccountId: string) => {\n    return internalAccountingService.getTrialBalance(subAccountId)\n  },\n\n  /**\n   * Get Accounts Receivable Aging\n   */\n  getARaging: (subAccountId: string) => {\n    return internalAccountingService.getAccountsReceivableAging(subAccountId)\n  },\n\n  /**\n   * Check if sub-account is Risivo Hub\n   */\n  isRisivoHub: (subAccountId: string): boolean => {\n    return accountingSyncService.isRisivoHub(subAccountId)\n  },\n\n  /**\n   * Get Risivo Hub sub-account ID constant\n   */\n  RISIVO_HUB_ID: RISIVO_HUB_SUB_ACCOUNT_ID,\n}\n\n// Default export\nexport default accountingAPI\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServer"],"mappings":"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","ignoreList":[0,1]}